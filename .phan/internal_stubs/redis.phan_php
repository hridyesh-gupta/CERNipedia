<?php
// These stubs were generated by the phan stub generator.
// @phan-stub-for-extension redis@6.2.0

namespace {
class Redis {

    // constants
    const REDIS_NOT_FOUND = 0;
    const REDIS_STRING = 1;
    const REDIS_SET = 2;
    const REDIS_LIST = 3;
    const REDIS_ZSET = 4;
    const REDIS_HASH = 5;
    const REDIS_STREAM = 6;
    const ATOMIC = 0;
    const MULTI = 1;
    const PIPELINE = 2;
    const OPT_SERIALIZER = 1;
    const OPT_PREFIX = 2;
    const OPT_READ_TIMEOUT = 3;
    const OPT_TCP_KEEPALIVE = 6;
    const OPT_COMPRESSION = 7;
    const OPT_REPLY_LITERAL = 8;
    const OPT_COMPRESSION_LEVEL = 9;
    const OPT_NULL_MULTIBULK_AS_NULL = 10;
    const OPT_PACK_IGNORE_NUMBERS = 15;
    const SERIALIZER_NONE = 0;
    const SERIALIZER_PHP = 1;
    const SERIALIZER_IGBINARY = 2;
    const SERIALIZER_JSON = 4;
    const COMPRESSION_NONE = 0;
    const COMPRESSION_LZF = 1;
    const COMPRESSION_ZSTD = 2;
    const COMPRESSION_ZSTD_DEFAULT = 3;
    const COMPRESSION_ZSTD_MIN = -131072;
    const COMPRESSION_ZSTD_MAX = 22;
    const COMPRESSION_LZ4 = 3;
    const OPT_SCAN = 4;
    const SCAN_RETRY = 1;
    const SCAN_NORETRY = 0;
    const SCAN_PREFIX = 2;
    const SCAN_NOPREFIX = 3;
    const BEFORE = 'before';
    const AFTER = 'after';
    const LEFT = 'left';
    const RIGHT = 'right';
    const OPT_MAX_RETRIES = 11;
    const OPT_BACKOFF_ALGORITHM = 12;
    const BACKOFF_ALGORITHM_DEFAULT = 0;
    const BACKOFF_ALGORITHM_CONSTANT = 6;
    const BACKOFF_ALGORITHM_UNIFORM = 5;
    const BACKOFF_ALGORITHM_EXPONENTIAL = 4;
    const BACKOFF_ALGORITHM_FULL_JITTER = 2;
    const BACKOFF_ALGORITHM_EQUAL_JITTER = 3;
    const BACKOFF_ALGORITHM_DECORRELATED_JITTER = 1;
    const OPT_BACKOFF_BASE = 13;
    const OPT_BACKOFF_CAP = 14;

    // methods
    public function __construct(?array $options = null) {}
    public function __destruct() {}
    public function _compress(string $value) : string {}
    public function _uncompress(string $value) : string {}
    public function _prefix(string $key) : string {}
    public function _serialize(mixed $value) : string {}
    public function _unserialize(string $value) : mixed {}
    public function _pack(mixed $value) : string {}
    public function _unpack(string $value) : mixed {}
    public function acl(string $subcmd, string ...$args) : mixed {}
    public function append(string $key, mixed $value) : \Redis|false|int {}
    public function auth(mixed $credentials) : \Redis|bool {}
    public function bgSave() : \Redis|bool {}
    public function bgrewriteaof() : \Redis|bool {}
    public function waitaof(int $numlocal, int $numreplicas, int $timeout) : \Redis|array|false {}
    public function bitcount(string $key, int $start = 0, int $end = -1, bool $bybit = false) : \Redis|false|int {}
    public function bitop(string $operation, string $deskey, string $srckey, string ...$other_keys) : \Redis|false|int {}
    public function bitpos(string $key, bool $bit, int $start = 0, int $end = -1, bool $bybit = false) : \Redis|false|int {}
    public function blPop(array|string $key_or_keys, float|int|string $timeout_or_key, mixed ...$extra_args) : \Redis|array|false|null {}
    public function brPop(array|string $key_or_keys, float|int|string $timeout_or_key, mixed ...$extra_args) : \Redis|array|false|null {}
    public function brpoplpush(string $src, string $dst, float|int $timeout) : \Redis|false|string {}
    public function bzPopMax(array|string $key, int|string $timeout_or_key, mixed ...$extra_args) : \Redis|array|false {}
    public function bzPopMin(array|string $key, int|string $timeout_or_key, mixed ...$extra_args) : \Redis|array|false {}
    public function bzmpop(float $timeout, array $keys, string $from, int $count = 1) : \Redis|array|false|null {}
    public function zmpop(array $keys, string $from, int $count = 1) : \Redis|array|false|null {}
    public function blmpop(float $timeout, array $keys, string $from, int $count = 1) : \Redis|array|false|null {}
    public function lmpop(array $keys, string $from, int $count = 1) : \Redis|array|false|null {}
    public function clearLastError() : bool {}
    public function client(string $opt, mixed ...$args) : mixed {}
    public function close() : bool {}
    public function command(?string $opt = null, mixed ...$args) : mixed {}
    public function config(string $operation, array|null|string $key_or_settings = null, ?string $value = null) : mixed {}
    public function connect(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null) : bool {}
    public function copy(string $src, string $dst, ?array $options = null) : \Redis|bool {}
    public function dbSize() : \Redis|false|int {}
    public function debug(string $key) : \Redis|string {}
    public function decr(string $key, int $by = 1) : \Redis|false|int {}
    public function decrBy(string $key, int $value) : \Redis|false|int {}
    public function del(array|string $key, string ...$other_keys) : \Redis|false|int {}
    public function delete(array|string $key, string ...$other_keys) : \Redis|false|int {}
    public function discard() : \Redis|bool {}
    public function dump(string $key) : \Redis|false|string {}
    public function echo(string $str) : \Redis|false|string {}
    public function eval(string $script, array $args = [], int $num_keys = 0) : mixed {}
    public function eval_ro(string $script_sha, array $args = [], int $num_keys = 0) : mixed {}
    public function evalsha(string $sha1, array $args = [], int $num_keys = 0) : mixed {}
    public function evalsha_ro(string $sha1, array $args = [], int $num_keys = 0) : mixed {}
    public function exec() : \Redis|array|false {}
    public function exists(mixed $key, mixed ...$other_keys) : \Redis|bool|int {}
    public function expire(string $key, int $timeout, ?string $mode = null) : \Redis|bool {}
    public function expireAt(string $key, int $timestamp, ?string $mode = null) : \Redis|bool {}
    public function failover(?array $to = null, bool $abort = false, int $timeout = 0) : \Redis|bool {}
    public function expiretime(string $key) : \Redis|false|int {}
    public function pexpiretime(string $key) : \Redis|false|int {}
    public function fcall(string $fn, array $keys = [], array $args = []) : mixed {}
    public function fcall_ro(string $fn, array $keys = [], array $args = []) : mixed {}
    public function flushAll(?bool $sync = null) : \Redis|bool {}
    public function flushDB(?bool $sync = null) : \Redis|bool {}
    public function function(string $operation, mixed ...$args) : \Redis|array|bool|string {}
    public function geoadd(string $key, float $lng, float $lat, string $member, mixed ...$other_triples_and_options) : \Redis|false|int {}
    public function geodist(string $key, string $src, string $dst, ?string $unit = null) : \Redis|false|float {}
    public function geohash(string $key, string $member, string ...$other_members) : \Redis|array|false {}
    public function geopos(string $key, string $member, string ...$other_members) : \Redis|array|false {}
    public function georadius(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []) : mixed {}
    public function georadius_ro(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []) : mixed {}
    public function georadiusbymember(string $key, string $member, float $radius, string $unit, array $options = []) : mixed {}
    public function georadiusbymember_ro(string $key, string $member, float $radius, string $unit, array $options = []) : mixed {}
    public function geosearch(string $key, array|string $position, array|float|int $shape, string $unit, array $options = []) : array {}
    public function geosearchstore(string $dst, string $src, array|string $position, array|float|int $shape, string $unit, array $options = []) : \Redis|array|false|int {}
    public function get(string $key) : mixed {}
    public function getWithMeta(string $key) : \Redis|array|false {}
    public function getAuth() : mixed {}
    public function getBit(string $key, int $idx) : \Redis|false|int {}
    public function getEx(string $key, array $options = []) : \Redis|bool|string {}
    public function getDBNum() : int {}
    public function getDel(string $key) : \Redis|bool|string {}
    public function getHost() : string {}
    public function getLastError() : ?string {}
    public function getMode() : int {}
    public function getOption(int $option) : mixed {}
    public function getPersistentID() : ?string {}
    public function getPort() : int {}
    public function serverName() : false|string {}
    public function serverVersion() : false|string {}
    public function getRange(string $key, int $start, int $end) : \Redis|false|string {}
    public function lcs(string $key1, string $key2, ?array $options = null) : \Redis|array|false|int|string {}
    public function getReadTimeout() : float {}
    public function getset(string $key, mixed $value) : \Redis|false|string {}
    public function getTimeout() : false|float {}
    public function getTransferredBytes() : array {}
    public function clearTransferredBytes() : void {}
    public function hDel(string $key, string $field, string ...$other_fields) : \Redis|false|int {}
    public function hExists(string $key, string $field) : \Redis|bool {}
    public function hGet(string $key, string $member) : mixed {}
    public function hGetAll(string $key) : \Redis|array|false {}
    public function hIncrBy(string $key, string $field, int $value) : \Redis|false|int {}
    public function hIncrByFloat(string $key, string $field, float $value) : \Redis|false|float {}
    public function hKeys(string $key) : \Redis|array|false {}
    public function hLen(string $key) : \Redis|false|int {}
    public function hMget(string $key, array $fields) : \Redis|array|false {}
    public function hMset(string $key, array $fieldvals) : \Redis|bool {}
    public function hRandField(string $key, ?array $options = null) : \Redis|array|false|string {}
    public function hSet(string $key, mixed ...$fields_and_vals) : \Redis|false|int {}
    public function hSetNx(string $key, string $field, mixed $value) : \Redis|bool {}
    public function hStrLen(string $key, string $field) : \Redis|false|int {}
    public function hVals(string $key) : \Redis|array|false {}
    public function hscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : \Redis|array|bool {}
    public function expiremember(string $key, string $field, int $ttl, ?string $unit = null) : \Redis|false|int {}
    public function expirememberat(string $key, string $field, int $timestamp) : \Redis|false|int {}
    public function incr(string $key, int $by = 1) : \Redis|false|int {}
    public function incrBy(string $key, int $value) : \Redis|false|int {}
    public function incrByFloat(string $key, float $value) : \Redis|false|float {}
    public function info(string ...$sections) : \Redis|array|false {}
    public function isConnected() : bool {}
    public function keys(string $pattern) {}
    public function lInsert(string $key, string $pos, mixed $pivot, mixed $value) {}
    public function lLen(string $key) : \Redis|false|int {}
    public function lMove(string $src, string $dst, string $wherefrom, string $whereto) : \Redis|false|string {}
    public function blmove(string $src, string $dst, string $wherefrom, string $whereto, float $timeout) : \Redis|false|string {}
    public function lPop(string $key, int $count = 0) : \Redis|array|bool|string {}
    public function lPos(string $key, mixed $value, ?array $options = null) : \Redis|array|bool|int|null {}
    public function lPush(string $key, mixed ...$elements) : \Redis|false|int {}
    public function rPush(string $key, mixed ...$elements) : \Redis|false|int {}
    public function lPushx(string $key, mixed $value) : \Redis|false|int {}
    public function rPushx(string $key, mixed $value) : \Redis|false|int {}
    public function lSet(string $key, int $index, mixed $value) : \Redis|bool {}
    public function lastSave() : int {}
    public function lindex(string $key, int $index) : mixed {}
    public function lrange(string $key, int $start, int $end) : \Redis|array|false {}
    public function lrem(string $key, mixed $value, int $count = 0) : \Redis|false|int {}
    public function ltrim(string $key, int $start, int $end) : \Redis|bool {}
    public function mget(array $keys) : \Redis|array|false {}
    public function migrate(string $host, int $port, array|string $key, int $dstdb, int $timeout, bool $copy = false, bool $replace = false, mixed $credentials = null) : \Redis|bool {}
    public function move(string $key, int $index) : \Redis|bool {}
    public function mset(array $key_values) : \Redis|bool {}
    public function msetnx(array $key_values) : \Redis|bool {}
    public function multi(int $value = \Redis::MULTI) : \Redis|bool {}
    public function object(string $subcommand, string $key) : \Redis|false|int|string {}
    public function open(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null) : bool {}
    public function pconnect(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null) : bool {}
    public function persist(string $key) : \Redis|bool {}
    public function pexpire(string $key, int $timeout, ?string $mode = null) : bool {}
    public function pexpireAt(string $key, int $timestamp, ?string $mode = null) : \Redis|bool {}
    public function pfadd(string $key, array $elements) : \Redis|int {}
    public function pfcount(array|string $key_or_keys) : \Redis|false|int {}
    public function pfmerge(string $dst, array $srckeys) : \Redis|bool {}
    public function ping(?string $message = null) : \Redis|bool|string {}
    public function pipeline() : \Redis|bool {}
    public function popen(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null) : bool {}
    public function psetex(string $key, int $expire, mixed $value) : \Redis|bool {}
    public function psubscribe(array $patterns, callable $cb) : bool {}
    public function pttl(string $key) : \Redis|false|int {}
    public function publish(string $channel, string $message) : \Redis|false|int {}
    public function pubsub(string $command, mixed $arg = null) : mixed {}
    public function punsubscribe(array $patterns) : \Redis|array|bool {}
    public function rPop(string $key, int $count = 0) : \Redis|array|bool|string {}
    public function randomKey() : \Redis|false|string {}
    public function rawcommand(string $command, mixed ...$args) : mixed {}
    public function rename(string $old_name, string $new_name) : \Redis|bool {}
    public function renameNx(string $key_src, string $key_dst) : \Redis|bool {}
    public function reset() : \Redis|bool {}
    public function restore(string $key, int $ttl, string $value, ?array $options = null) : \Redis|bool {}
    public function role() : mixed {}
    public function rpoplpush(string $srckey, string $dstkey) : \Redis|false|string {}
    public function sAdd(string $key, mixed $value, mixed ...$other_values) : \Redis|false|int {}
    public function sAddArray(string $key, array $values) : int {}
    public function sDiff(string $key, string ...$other_keys) : \Redis|array|false {}
    public function sDiffStore(string $dst, string $key, string ...$other_keys) : \Redis|false|int {}
    public function sInter(array|string $key, string ...$other_keys) : \Redis|array|false {}
    public function sintercard(array $keys, int $limit = -1) : \Redis|false|int {}
    public function sInterStore(array|string $key, string ...$other_keys) : \Redis|false|int {}
    public function sMembers(string $key) : \Redis|array|false {}
    public function sMisMember(string $key, string $member, string ...$other_members) : \Redis|array|false {}
    public function sMove(string $src, string $dst, mixed $value) : \Redis|bool {}
    public function sPop(string $key, int $count = 0) : \Redis|array|false|string {}
    public function sRandMember(string $key, int $count = 0) : mixed {}
    public function sUnion(string $key, string ...$other_keys) : \Redis|array|false {}
    public function sUnionStore(string $dst, string $key, string ...$other_keys) : \Redis|false|int {}
    public function save() : \Redis|bool {}
    public function scan(int|null|string &$iterator, ?string $pattern = null, int $count = 0, ?string $type = null) : array|false {}
    public function scard(string $key) : \Redis|false|int {}
    public function script(string $command, mixed ...$args) : mixed {}
    public function select(int $db) : \Redis|bool {}
    public function set(string $key, mixed $value, mixed $options = null) : \Redis|bool|string {}
    public function setBit(string $key, int $idx, bool $value) : \Redis|false|int {}
    public function setRange(string $key, int $index, string $value) : \Redis|false|int {}
    public function setOption(int $option, mixed $value) : bool {}
    public function setex(string $key, int $expire, mixed $value) {}
    public function setnx(string $key, mixed $value) : \Redis|bool {}
    public function sismember(string $key, mixed $value) : \Redis|bool {}
    public function slaveof(?string $host = null, int $port = 6379) : \Redis|bool {}
    public function replicaof(?string $host = null, int $port = 6379) : \Redis|bool {}
    public function touch(array|string $key_or_array, string ...$more_keys) : \Redis|false|int {}
    public function slowlog(string $operation, int $length = 0) : mixed {}
    public function sort(string $key, ?array $options = null) : mixed {}
    public function sort_ro(string $key, ?array $options = null) : mixed {}
    public function sortAsc(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null) : array {}
    public function sortAscAlpha(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null) : array {}
    public function sortDesc(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null) : array {}
    public function sortDescAlpha(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null) : array {}
    public function srem(string $key, mixed $value, mixed ...$other_values) : \Redis|false|int {}
    public function sscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|false {}
    public function ssubscribe(array $channels, callable $cb) : bool {}
    public function strlen(string $key) : \Redis|false|int {}
    public function subscribe(array $channels, callable $cb) : bool {}
    public function sunsubscribe(array $channels) : \Redis|array|bool {}
    public function swapdb(int $src, int $dst) : \Redis|bool {}
    public function time() : \Redis|array {}
    public function ttl(string $key) : \Redis|false|int {}
    public function type(string $key) : \Redis|false|int {}
    public function unlink(array|string $key, string ...$other_keys) : \Redis|false|int {}
    public function unsubscribe(array $channels) : \Redis|array|bool {}
    public function unwatch() : \Redis|bool {}
    public function watch(array|string $key, string ...$other_keys) : \Redis|bool {}
    public function wait(int $numreplicas, int $timeout) : false|int {}
    public function xack(string $key, string $group, array $ids) : false|int {}
    public function xadd(string $key, string $id, array $values, int $maxlen = 0, bool $approx = false, bool $nomkstream = false) : \Redis|false|string {}
    public function xautoclaim(string $key, string $group, string $consumer, int $min_idle, string $start, int $count = -1, bool $justid = false) : \Redis|array|bool {}
    public function xclaim(string $key, string $group, string $consumer, int $min_idle, array $ids, array $options) : \Redis|array|bool {}
    public function xdel(string $key, array $ids) : \Redis|false|int {}
    public function xgroup(string $operation, ?string $key = null, ?string $group = null, ?string $id_or_consumer = null, bool $mkstream = false, int $entries_read = -2) : mixed {}
    public function xinfo(string $operation, ?string $arg1 = null, ?string $arg2 = null, int $count = -1) : mixed {}
    public function xlen(string $key) : \Redis|false|int {}
    public function xpending(string $key, string $group, ?string $start = null, ?string $end = null, int $count = -1, ?string $consumer = null) : \Redis|array|false {}
    public function xrange(string $key, string $start, string $end, int $count = -1) : \Redis|array|bool {}
    public function xread(array $streams, int $count = -1, int $block = -1) : \Redis|array|bool {}
    public function xreadgroup(string $group, string $consumer, array $streams, int $count = 1, int $block = 1) : \Redis|array|bool {}
    public function xrevrange(string $key, string $end, string $start, int $count = -1) : \Redis|array|bool {}
    public function xtrim(string $key, string $threshold, bool $approx = false, bool $minid = false, int $limit = -1) : \Redis|false|int {}
    public function zAdd(string $key, array|float $score_or_options, mixed ...$more_scores_and_mems) : \Redis|false|float|int {}
    public function zCard(string $key) : \Redis|false|int {}
    public function zCount(string $key, int|string $start, int|string $end) : \Redis|false|int {}
    public function zIncrBy(string $key, float $value, mixed $member) : \Redis|false|float {}
    public function zLexCount(string $key, string $min, string $max) : \Redis|false|int {}
    public function zMscore(string $key, mixed $member, mixed ...$other_members) : \Redis|array|false {}
    public function zPopMax(string $key, ?int $count = null) : \Redis|array|false {}
    public function zPopMin(string $key, ?int $count = null) : \Redis|array|false {}
    public function zRange(string $key, int|string $start, int|string $end, array|bool|null $options = null) : \Redis|array|false {}
    public function zRangeByLex(string $key, string $min, string $max, int $offset = -1, int $count = -1) : \Redis|array|false {}
    public function zRangeByScore(string $key, string $start, string $end, array $options = []) : \Redis|array|false {}
    public function zrangestore(string $dstkey, string $srckey, string $start, string $end, array|bool|null $options = null) : \Redis|false|int {}
    public function zRandMember(string $key, ?array $options = null) : \Redis|array|string {}
    public function zRank(string $key, mixed $member) : \Redis|false|int {}
    public function zRem(mixed $key, mixed $member, mixed ...$other_members) : \Redis|false|int {}
    public function zRemRangeByLex(string $key, string $min, string $max) : \Redis|false|int {}
    public function zRemRangeByRank(string $key, int $start, int $end) : \Redis|false|int {}
    public function zRemRangeByScore(string $key, string $start, string $end) : \Redis|false|int {}
    public function zRevRange(string $key, int $start, int $end, mixed $scores = null) : \Redis|array|false {}
    public function zRevRangeByLex(string $key, string $max, string $min, int $offset = -1, int $count = -1) : \Redis|array|false {}
    public function zRevRangeByScore(string $key, string $max, string $min, array|bool $options = []) : \Redis|array|false {}
    public function zRevRank(string $key, mixed $member) : \Redis|false|int {}
    public function zScore(string $key, mixed $member) : \Redis|false|float {}
    public function zdiff(array $keys, ?array $options = null) : \Redis|array|false {}
    public function zdiffstore(string $dst, array $keys) : \Redis|false|int {}
    public function zinter(array $keys, ?array $weights = null, ?array $options = null) : \Redis|array|false {}
    public function zintercard(array $keys, int $limit = -1) : \Redis|false|int {}
    public function zinterstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null) : \Redis|false|int {}
    public function zscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : \Redis|array|false {}
    public function zunion(array $keys, ?array $weights = null, ?array $options = null) : \Redis|array|false {}
    public function zunionstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null) : \Redis|false|int {}
}

class RedisArray {

    // methods
    public function __call(string $function_name, array $arguments) : mixed {}
    public function __construct(array|string $name_or_hosts, ?array $options = null) {}
    public function _continuum() : array|bool {}
    public function _distributor() : bool|callable {}
    public function _function() : bool|callable {}
    public function _hosts() : array|bool {}
    public function _instance(string $host) : \Redis|bool|null {}
    public function _rehash(?callable $fn = null) : ?bool {}
    public function _target(string $key) : bool|null|string {}
    public function bgsave() : array {}
    public function del(array|string $key, string ...$otherkeys) : bool|int {}
    public function discard() : ?bool {}
    public function exec() : array|bool|null {}
    public function flushall() : array|bool {}
    public function flushdb() : array|bool {}
    public function getOption(int $opt) : array|bool {}
    public function hscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|bool {}
    public function info() : array|bool {}
    public function keys(string $pattern) : array|bool {}
    public function mget(array $keys) : array|bool {}
    public function mset(array $pairs) : bool {}
    public function multi(string $host, ?int $mode = null) : \RedisArray|bool {}
    public function ping() : array|bool {}
    public function save() : array|bool {}
    public function scan(int|null|string &$iterator, string $node, ?string $pattern = null, int $count = 0) : array|bool {}
    public function select(int $index) : array|bool {}
    public function setOption(int $opt, string $value) : array|bool {}
    public function sscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|bool {}
    public function unlink(array|string $key, string ...$otherkeys) : bool|int {}
    public function unwatch() : ?bool {}
    public function zscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|bool {}
}

class RedisCluster {

    // constants
    const OPT_SLAVE_FAILOVER = 5;
    const FAILOVER_NONE = 0;
    const FAILOVER_ERROR = 1;
    const FAILOVER_DISTRIBUTE = 2;
    const FAILOVER_DISTRIBUTE_SLAVES = 3;

    // methods
    public function __construct(?string $name, ?array $seeds = null, float|int $timeout = 0, float|int $read_timeout = 0, bool $persistent = false, mixed $auth = null, ?array $context = null) {}
    public function _compress(string $value) : string {}
    public function _uncompress(string $value) : string {}
    public function _serialize(mixed $value) : bool|string {}
    public function _unserialize(string $value) : mixed {}
    public function _pack(mixed $value) : string {}
    public function _unpack(string $value) : mixed {}
    public function _prefix(string $key) : bool|string {}
    public function _masters() : array {}
    public function _redir() : ?string {}
    public function acl(array|string $key_or_address, string $subcmd, string ...$args) : mixed {}
    public function append(string $key, mixed $value) : \RedisCluster|bool|int {}
    public function bgrewriteaof(array|string $key_or_address) : \RedisCluster|bool {}
    public function waitaof(array|string $key_or_address, int $numlocal, int $numreplicas, int $timeout) : \RedisCluster|array|false {}
    public function bgsave(array|string $key_or_address) : \RedisCluster|bool {}
    public function bitcount(string $key, int $start = 0, int $end = -1, bool $bybit = false) : \RedisCluster|bool|int {}
    public function bitop(string $operation, string $deskey, string $srckey, string ...$otherkeys) : \RedisCluster|bool|int {}
    public function bitpos(string $key, bool $bit, int $start = 0, int $end = -1, bool $bybit = false) : \RedisCluster|false|int {}
    public function blpop(array|string $key, float|int|string $timeout_or_key, mixed ...$extra_args) : \RedisCluster|array|false|null {}
    public function brpop(array|string $key, float|int|string $timeout_or_key, mixed ...$extra_args) : \RedisCluster|array|false|null {}
    public function brpoplpush(string $srckey, string $deskey, int $timeout) : mixed {}
    public function lmove(string $src, string $dst, string $wherefrom, string $whereto) : \Redis|false|string {}
    public function blmove(string $src, string $dst, string $wherefrom, string $whereto, float $timeout) : \Redis|false|string {}
    public function bzpopmax(array|string $key, int|string $timeout_or_key, mixed ...$extra_args) : array {}
    public function bzpopmin(array|string $key, int|string $timeout_or_key, mixed ...$extra_args) : array {}
    public function bzmpop(float $timeout, array $keys, string $from, int $count = 1) : \RedisCluster|array|false|null {}
    public function zmpop(array $keys, string $from, int $count = 1) : \RedisCluster|array|false|null {}
    public function blmpop(float $timeout, array $keys, string $from, int $count = 1) : \RedisCluster|array|false|null {}
    public function lmpop(array $keys, string $from, int $count = 1) : \RedisCluster|array|false|null {}
    public function clearlasterror() : bool {}
    public function client(array|string $key_or_address, string $subcommand, ?string $arg = null) : array|bool|string {}
    public function close() : bool {}
    public function cluster(array|string $key_or_address, string $command, mixed ...$extra_args) : mixed {}
    public function command(mixed ...$extra_args) : mixed {}
    public function config(array|string $key_or_address, string $subcommand, mixed ...$extra_args) : mixed {}
    public function dbsize(array|string $key_or_address) : \RedisCluster|int {}
    public function copy(string $src, string $dst, ?array $options = null) : \RedisCluster|bool {}
    public function decr(string $key, int $by = 1) : \RedisCluster|false|int {}
    public function decrby(string $key, int $value) : \RedisCluster|false|int {}
    public function decrbyfloat(string $key, float $value) : float {}
    public function del(array|string $key, string ...$other_keys) : \RedisCluster|false|int {}
    public function discard() : bool {}
    public function dump(string $key) : \RedisCluster|false|string {}
    public function echo(array|string $key_or_address, string $msg) : \RedisCluster|false|string {}
    public function eval(string $script, array $args = [], int $num_keys = 0) : mixed {}
    public function eval_ro(string $script, array $args = [], int $num_keys = 0) : mixed {}
    public function evalsha(string $script_sha, array $args = [], int $num_keys = 0) : mixed {}
    public function evalsha_ro(string $script_sha, array $args = [], int $num_keys = 0) : mixed {}
    public function exec() : array|false {}
    public function exists(mixed $key, mixed ...$other_keys) : \RedisCluster|bool|int {}
    public function touch(mixed $key, mixed ...$other_keys) : \RedisCluster|bool|int {}
    public function expire(string $key, int $timeout, ?string $mode = null) : \RedisCluster|bool {}
    public function expireat(string $key, int $timestamp, ?string $mode = null) : \RedisCluster|bool {}
    public function expiretime(string $key) : \RedisCluster|false|int {}
    public function pexpiretime(string $key) : \RedisCluster|false|int {}
    public function flushall(array|string $key_or_address, bool $async = false) : \RedisCluster|bool {}
    public function flushdb(array|string $key_or_address, bool $async = false) : \RedisCluster|bool {}
    public function geoadd(string $key, float $lng, float $lat, string $member, mixed ...$other_triples_and_options) : \RedisCluster|false|int {}
    public function geodist(string $key, string $src, string $dest, ?string $unit = null) : \RedisCluster|false|float {}
    public function geohash(string $key, string $member, string ...$other_members) : \RedisCluster|array|false {}
    public function geopos(string $key, string $member, string ...$other_members) : \RedisCluster|array|false {}
    public function georadius(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []) : mixed {}
    public function georadius_ro(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []) : mixed {}
    public function georadiusbymember(string $key, string $member, float $radius, string $unit, array $options = []) : mixed {}
    public function georadiusbymember_ro(string $key, string $member, float $radius, string $unit, array $options = []) : mixed {}
    public function geosearch(string $key, array|string $position, array|float|int $shape, string $unit, array $options = []) : \RedisCluster|array {}
    public function geosearchstore(string $dst, string $src, array|string $position, array|float|int $shape, string $unit, array $options = []) : \RedisCluster|array|false|int {}
    public function get(string $key) : mixed {}
    public function getdel(string $key) : mixed {}
    public function getWithMeta(string $key) : \RedisCluster|array|false {}
    public function getex(string $key, array $options = []) : \RedisCluster|false|string {}
    public function getbit(string $key, int $value) : \RedisCluster|false|int {}
    public function getlasterror() : ?string {}
    public function getmode() : int {}
    public function getoption(int $option) : mixed {}
    public function getrange(string $key, int $start, int $end) : \RedisCluster|false|string {}
    public function lcs(string $key1, string $key2, ?array $options = null) : \RedisCluster|array|false|int|string {}
    public function getset(string $key, mixed $value) : \RedisCluster|bool|string {}
    public function gettransferredbytes() : array|false {}
    public function cleartransferredbytes() : void {}
    public function hdel(string $key, string $member, string ...$other_members) : \RedisCluster|false|int {}
    public function hexists(string $key, string $member) : \RedisCluster|bool {}
    public function hget(string $key, string $member) : mixed {}
    public function hgetall(string $key) : \RedisCluster|array|false {}
    public function hincrby(string $key, string $member, int $value) : \RedisCluster|false|int {}
    public function hincrbyfloat(string $key, string $member, float $value) : \RedisCluster|false|float {}
    public function hkeys(string $key) : \RedisCluster|array|false {}
    public function hlen(string $key) : \RedisCluster|false|int {}
    public function hmget(string $key, array $keys) : \RedisCluster|array|false {}
    public function hmset(string $key, array $key_values) : \RedisCluster|bool {}
    public function hscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|bool {}
    public function expiremember(string $key, string $field, int $ttl, ?string $unit = null) : \Redis|false|int {}
    public function expirememberat(string $key, string $field, int $timestamp) : \Redis|false|int {}
    public function hrandfield(string $key, ?array $options = null) : \RedisCluster|array|string {}
    public function hset(string $key, string $member, mixed $value) : \RedisCluster|false|int {}
    public function hsetnx(string $key, string $member, mixed $value) : \RedisCluster|bool {}
    public function hstrlen(string $key, string $field) : \RedisCluster|false|int {}
    public function hvals(string $key) : \RedisCluster|array|false {}
    public function incr(string $key, int $by = 1) : \RedisCluster|false|int {}
    public function incrby(string $key, int $value) : \RedisCluster|false|int {}
    public function incrbyfloat(string $key, float $value) : \RedisCluster|false|float {}
    public function info(array|string $key_or_address, string ...$sections) : \RedisCluster|array|false {}
    public function keys(string $pattern) : \RedisCluster|array|false {}
    public function lastsave(array|string $key_or_address) : \RedisCluster|false|int {}
    public function lget(string $key, int $index) : \RedisCluster|bool|string {}
    public function lindex(string $key, int $index) : mixed {}
    public function linsert(string $key, string $pos, mixed $pivot, mixed $value) : \RedisCluster|false|int {}
    public function llen(string $key) : \RedisCluster|bool|int {}
    public function lpop(string $key, int $count = 0) : \RedisCluster|array|bool|string {}
    public function lpos(string $key, mixed $value, ?array $options = null) : \Redis|array|bool|int|null {}
    public function lpush(string $key, mixed $value, mixed ...$other_values) : \RedisCluster|bool|int {}
    public function lpushx(string $key, mixed $value) : \RedisCluster|bool|int {}
    public function lrange(string $key, int $start, int $end) : \RedisCluster|array|false {}
    public function lrem(string $key, mixed $value, int $count = 0) : \RedisCluster|bool|int {}
    public function lset(string $key, int $index, mixed $value) : \RedisCluster|bool {}
    public function ltrim(string $key, int $start, int $end) : \RedisCluster|bool {}
    public function mget(array $keys) : \RedisCluster|array|false {}
    public function mset(array $key_values) : \RedisCluster|bool {}
    public function msetnx(array $key_values) : \RedisCluster|array|false {}
    public function multi(int $value = \Redis::MULTI) : \RedisCluster|bool {}
    public function object(string $subcommand, string $key) : \RedisCluster|false|int|string {}
    public function persist(string $key) : \RedisCluster|bool {}
    public function pexpire(string $key, int $timeout, ?string $mode = null) : \RedisCluster|bool {}
    public function pexpireat(string $key, int $timestamp, ?string $mode = null) : \RedisCluster|bool {}
    public function pfadd(string $key, array $elements) : \RedisCluster|bool {}
    public function pfcount(string $key) : \RedisCluster|false|int {}
    public function pfmerge(string $key, array $keys) : \RedisCluster|bool {}
    public function ping(array|string $key_or_address, ?string $message = null) : mixed {}
    public function psetex(string $key, int $timeout, string $value) : \RedisCluster|bool {}
    public function psubscribe(array $patterns, callable $callback) : void {}
    public function pttl(string $key) : \RedisCluster|false|int {}
    public function publish(string $channel, string $message) : \RedisCluster|bool|int {}
    public function pubsub(array|string $key_or_address, string ...$values) : mixed {}
    public function punsubscribe(string $pattern, string ...$other_patterns) : array|bool {}
    public function randomkey(array|string $key_or_address) : \RedisCluster|bool|string {}
    public function rawcommand(array|string $key_or_address, string $command, mixed ...$args) : mixed {}
    public function rename(string $key_src, string $key_dst) : \RedisCluster|bool {}
    public function renamenx(string $key, string $newkey) : \RedisCluster|bool {}
    public function restore(string $key, int $timeout, string $value, ?array $options = null) : \RedisCluster|bool {}
    public function role(array|string $key_or_address) : mixed {}
    public function rpop(string $key, int $count = 0) : \RedisCluster|array|bool|string {}
    public function rpoplpush(string $src, string $dst) : \RedisCluster|bool|string {}
    public function rpush(string $key, mixed ...$elements) : \RedisCluster|false|int {}
    public function rpushx(string $key, string $value) : \RedisCluster|bool|int {}
    public function sadd(string $key, mixed $value, mixed ...$other_values) : \RedisCluster|false|int {}
    public function saddarray(string $key, array $values) : \RedisCluster|bool|int {}
    public function save(array|string $key_or_address) : \RedisCluster|bool {}
    public function scan(int|null|string &$iterator, array|string $key_or_address, ?string $pattern = null, int $count = 0) : array|bool {}
    public function scard(string $key) : \RedisCluster|false|int {}
    public function script(array|string $key_or_address, mixed ...$args) : mixed {}
    public function sdiff(string $key, string ...$other_keys) : \RedisCluster|array|false {}
    public function sdiffstore(string $dst, string $key, string ...$other_keys) : \RedisCluster|false|int {}
    public function set(string $key, mixed $value, mixed $options = null) : \RedisCluster|bool|string {}
    public function setbit(string $key, int $offset, bool $onoff) : \RedisCluster|false|int {}
    public function setex(string $key, int $expire, mixed $value) : \RedisCluster|bool {}
    public function setnx(string $key, mixed $value) : \RedisCluster|bool {}
    public function setoption(int $option, mixed $value) : bool {}
    public function setrange(string $key, int $offset, string $value) : \RedisCluster|false|int {}
    public function sinter(array|string $key, string ...$other_keys) : \RedisCluster|array|false {}
    public function sintercard(array $keys, int $limit = -1) : \RedisCluster|false|int {}
    public function sinterstore(array|string $key, string ...$other_keys) : \RedisCluster|false|int {}
    public function sismember(string $key, mixed $value) : \RedisCluster|bool {}
    public function smismember(string $key, string $member, string ...$other_members) : \RedisCluster|array|false {}
    public function slowlog(array|string $key_or_address, mixed ...$args) : mixed {}
    public function smembers(string $key) : \RedisCluster|array|false {}
    public function smove(string $src, string $dst, string $member) : \RedisCluster|bool {}
    public function sort(string $key, ?array $options = null) : \RedisCluster|array|bool|int|string {}
    public function sort_ro(string $key, ?array $options = null) : \RedisCluster|array|bool|int|string {}
    public function spop(string $key, int $count = 0) : \RedisCluster|array|false|string {}
    public function srandmember(string $key, int $count = 0) : \RedisCluster|array|false|string {}
    public function srem(string $key, mixed $value, mixed ...$other_values) : \RedisCluster|false|int {}
    public function sscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : array|false {}
    public function strlen(string $key) : \RedisCluster|false|int {}
    public function subscribe(array $channels, callable $cb) : void {}
    public function sunion(string $key, string ...$other_keys) : \RedisCluster|array|bool {}
    public function sunionstore(string $dst, string $key, string ...$other_keys) : \RedisCluster|false|int {}
    public function time(array|string $key_or_address) : \RedisCluster|array|bool {}
    public function ttl(string $key) : \RedisCluster|false|int {}
    public function type(string $key) : \RedisCluster|false|int {}
    public function unsubscribe(array $channels) : array|bool {}
    public function unlink(array|string $key, string ...$other_keys) : \RedisCluster|false|int {}
    public function unwatch() : bool {}
    public function watch(string $key, string ...$other_keys) : \RedisCluster|bool {}
    public function xack(string $key, string $group, array $ids) : \RedisCluster|false|int {}
    public function xadd(string $key, string $id, array $values, int $maxlen = 0, bool $approx = false) : \RedisCluster|false|string {}
    public function xclaim(string $key, string $group, string $consumer, int $min_iddle, array $ids, array $options) : \RedisCluster|array|false|string {}
    public function xdel(string $key, array $ids) : \RedisCluster|false|int {}
    public function xgroup(string $operation, ?string $key = null, ?string $group = null, ?string $id_or_consumer = null, bool $mkstream = false, int $entries_read = -2) : mixed {}
    public function xautoclaim(string $key, string $group, string $consumer, int $min_idle, string $start, int $count = -1, bool $justid = false) : \RedisCluster|array|bool {}
    public function xinfo(string $operation, ?string $arg1 = null, ?string $arg2 = null, int $count = -1) : mixed {}
    public function xlen(string $key) : \RedisCluster|false|int {}
    public function xpending(string $key, string $group, ?string $start = null, ?string $end = null, int $count = -1, ?string $consumer = null) : \RedisCluster|array|false {}
    public function xrange(string $key, string $start, string $end, int $count = -1) : \RedisCluster|array|bool {}
    public function xread(array $streams, int $count = -1, int $block = -1) : \RedisCluster|array|bool {}
    public function xreadgroup(string $group, string $consumer, array $streams, int $count = 1, int $block = 1) : \RedisCluster|array|bool {}
    public function xrevrange(string $key, string $start, string $end, int $count = -1) : \RedisCluster|array|bool {}
    public function xtrim(string $key, int $maxlen, bool $approx = false, bool $minid = false, int $limit = -1) : \RedisCluster|false|int {}
    public function zadd(string $key, array|float $score_or_options, mixed ...$more_scores_and_mems) : \RedisCluster|false|float|int {}
    public function zcard(string $key) : \RedisCluster|false|int {}
    public function zcount(string $key, string $start, string $end) : \RedisCluster|false|int {}
    public function zincrby(string $key, float $value, string $member) : \RedisCluster|false|float {}
    public function zinterstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null) : \RedisCluster|false|int {}
    public function zintercard(array $keys, int $limit = -1) : \RedisCluster|false|int {}
    public function zlexcount(string $key, string $min, string $max) : \RedisCluster|false|int {}
    public function zpopmax(string $key, ?int $value = null) : \RedisCluster|array|bool {}
    public function zpopmin(string $key, ?int $value = null) : \RedisCluster|array|bool {}
    public function zrange(string $key, mixed $start, mixed $end, array|bool|null $options = null) : \RedisCluster|array|bool {}
    public function zrangestore(string $dstkey, string $srckey, int $start, int $end, array|bool|null $options = null) : \RedisCluster|false|int {}
    public function zrandmember(string $key, ?array $options = null) : \RedisCluster|array|string {}
    public function zrangebylex(string $key, string $min, string $max, int $offset = -1, int $count = -1) : \RedisCluster|array|false {}
    public function zrangebyscore(string $key, string $start, string $end, array $options = []) : \RedisCluster|array|false {}
    public function zrank(string $key, mixed $member) : \RedisCluster|false|int {}
    public function zrem(string $key, string $value, string ...$other_values) : \RedisCluster|false|int {}
    public function zremrangebylex(string $key, string $min, string $max) : \RedisCluster|false|int {}
    public function zremrangebyrank(string $key, string $min, string $max) : \RedisCluster|false|int {}
    public function zremrangebyscore(string $key, string $min, string $max) : \RedisCluster|false|int {}
    public function zrevrange(string $key, string $min, string $max, ?array $options = null) : \RedisCluster|array|bool {}
    public function zrevrangebylex(string $key, string $min, string $max, ?array $options = null) : \RedisCluster|array|bool {}
    public function zrevrangebyscore(string $key, string $min, string $max, ?array $options = null) : \RedisCluster|array|bool {}
    public function zrevrank(string $key, mixed $member) : \RedisCluster|false|int {}
    public function zscan(string $key, int|null|string &$iterator, ?string $pattern = null, int $count = 0) : \RedisCluster|array|bool {}
    public function zscore(string $key, mixed $member) : \RedisCluster|false|float {}
    public function zmscore(string $key, mixed $member, mixed ...$other_members) : \Redis|array|false {}
    public function zunionstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null) : \RedisCluster|false|int {}
    public function zinter(array $keys, ?array $weights = null, ?array $options = null) : \RedisCluster|array|false {}
    public function zdiffstore(string $dst, array $keys) : \RedisCluster|false|int {}
    public function zunion(array $keys, ?array $weights = null, ?array $options = null) : \RedisCluster|array|false {}
    public function zdiff(array $keys, ?array $options = null) : \RedisCluster|array|false {}
}

class RedisClusterException extends \RuntimeException {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class RedisException extends \RuntimeException {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class RedisSentinel {

    // methods
    public function __construct(?array $options = null) {}
    public function ckquorum(string $master) {}
    public function failover(string $master) {}
    public function flushconfig() {}
    public function getMasterAddrByName(string $master) {}
    public function master(string $master) {}
    public function masters() {}
    public function myid() : string {}
    public function ping() {}
    public function reset(string $pattern) {}
    public function sentinels(string $master) {}
    public function slaves(string $master) {}
}

}
